import { RealFileService } from '../services/RealFileService';
import { FileItem, EditorTab } from '../models/FileModel';
import { HighlightedText } from '../components/HighlightedText';
import { MarkdownPreview } from '../components/MarkdownPreview';
import { MarkdownService } from '../services/MarkdownService';
import { ThemeService, Theme } from '../services/ThemeService';
import { SearchDialog } from '../components/SearchDialog';
import { SearchResult } from '../services/SearchService';
import { common } from '@kit.AbilityKit';
import { FileTreeItem } from '../components/FileTreeItem';

@Entry
@Component
struct CodeEditor {
  private fileService: RealFileService = new RealFileService();
  private context: common.UIAbilityContext | null = null;
  private markdownService: MarkdownService = new MarkdownService();
  private themeService: ThemeService = new ThemeService();

  @State currentFile: string = '';
  @State isFileTreeVisible: boolean = true;
  @State fileTree: FileItem[] = [];
  @State currentFolder: string = '';
  @State tabs: EditorTab[] = [];
  @State activeTab: EditorTab | null = null;
  @State editorContent: string = '';
  @State isLoading: boolean = false;
  @State expandedFolders: Set<string> = new Set();
  @State isPreviewMode: boolean = false;
  @State isMarkdownFile: boolean = false;
  @State showSearchDialog: boolean = false;
  @State currentTheme: Theme = this.themeService.getCurrentTheme();

  private autoSaveInterval: number | null = null;

  aboutToAppear() {
    this.context = this.getUIContext().getHostContext() as common.UIAbilityContext;
    this.fileService.setContext(this.context);
    this.setupThemeListener();
    this.loadSavedTheme();
    this.setupAutoSave();
  }

  aboutToDisappear() {
    this.cleanupAutoSave();
  }

  private setupThemeListener() {
    this.themeService.onThemeChange((theme: Theme) => {
      this.currentTheme = theme;
    });
  }

  private async loadSavedTheme() {
    try {
      const savedThemeId = await this.themeService.loadThemePreference();
      if (savedThemeId) {
        this.themeService.switchTheme(savedThemeId);
      }
    } catch (error) {
      console.error('Âä†ËΩΩ‰∏ªÈ¢òËÆæÁΩÆÂ§±Ë¥•:', error);
    }
  }

  build() {
    Navigation() {
        Column() {
        // È°∂ÈÉ®Â∑•ÂÖ∑Ê†è
        this.buildToolbar()

        // Ê†áÁ≠æÊ†è
          if (this.tabs.length > 0) {
          this.buildTabBar()
          }

        // ‰∏ªÂ∑•‰ΩúÂå∫
          Row() {
          // ‰æßËæπÊ†è
            if (this.isFileTreeVisible) {
            this.buildSidebar()
            }

          // ÁºñËæëÂô®Âå∫Âüü
          this.buildEditor()
          }
          .layoutWeight(1)
        .backgroundColor($r('app.color.background_primary'))
        }
        .width('100%')
      .height('100%')

      // ÊêúÁ¥¢ÂØπËØùÊ°Ü
        if (this.showSearchDialog) {
          SearchDialog({
            visible: this.showSearchDialog,
          onClose: () => { this.showSearchDialog = false; },
            onResultSelect: (result: SearchResult) => {
              this.handleSearchResult(result);
            }
          })
        }
      }
    .hideTitleBar(true)
  }

  @Builder
  buildToolbar(): void {
      Row() {
      // Â∑¶‰æßÊìç‰ΩúÊåâÈíÆ
        Row() {
        this.buildToolButton('üìÅ', 'ÊâìÂºÄÊñá‰ª∂Â§π', (): void => { 
          console.log('[ÊåâÈíÆÁÇπÂáª] ÊâìÂºÄÊñá‰ª∂Â§π');
          this.openFolderDialog(); 
        })
        this.buildToolButton('üìÑ', 'ÊâìÂºÄÊñá‰ª∂', (): void => { 
          console.log('[ÊåâÈíÆÁÇπÂáª] ÊâìÂºÄÊñá‰ª∂');
          this.openFileDialog(); 
        })
        this.buildToolButton('üíæ', '‰øùÂ≠ò', (): void => { 
          console.log('[ÊåâÈíÆÁÇπÂáª] ‰øùÂ≠òÊñá‰ª∂');
          this.saveCurrentFile(); 
        }, !!this.activeTab)
        
        // Markdown È¢ÑËßàÂàáÊç¢
        if (this.isMarkdownFile) {
          Divider()
            .vertical(true)
            .height(20)
            .color($r('app.color.border_light'))
            .margin({ left: 12, right: 12 })
          
          this.buildToggleButton(this.isPreviewMode ? 'üìù ÁºñËæë' : 'üëÅ È¢ÑËßà', (): void => { this.togglePreviewMode(); })
          }
        }
        .alignItems(VerticalAlign.Center)

      Blank()

      // Âè≥‰æßÂäüËÉΩÊåâÈíÆ
        Row() {
          this.buildIconButton('üîç', (): void => { this.showSearchDialog = true; })
        this.buildIconButton('üé®', (): void => { this.cycleTheme(); })
        this.buildIconButton(this.isFileTreeVisible ? '‚óß' : '‚ó®', (): void => {
          this.isFileTreeVisible = !this.isFileTreeVisible;
        })
        }
        .alignItems(VerticalAlign.Center)
      }
    .width('100%')
    .height(56)
    .padding({ left: 20, right: 20 })
      .backgroundColor($r('app.color.surface_elevated'))
    .border({ width: { bottom: 1 }, color: $r('app.color.border_light') })
  }

  @Builder
  buildToolButton(icon: string, label: string, action: () => void, enabled: boolean = true): void {
    Button({ type: ButtonType.Normal, stateEffect: true }) {
      Row() {
        Text(icon).fontSize(16).margin({ right: 6 })
        Text(label).fontSize(14).fontWeight(FontWeight.Medium)
      }
    }
    .height(36)
    .padding({ left: 14, right: 14 })
    .backgroundColor(Color.Transparent)
    .borderRadius(8)
    .fontColor(enabled ? $r('app.color.text_primary') : $r('app.color.text_tertiary'))
    .enabled(enabled)
    .onClick(action)
    .margin({ right: 8 })
    .stateStyles({
      normal: {
        .backgroundColor(Color.Transparent)
      },
      pressed: {
        .backgroundColor($r('app.color.hover_bg'))
      }
    })
  }

  @Builder
  buildToggleButton(label: string, action: () => void): void {
    Button({ type: ButtonType.Normal }) {
      Text(label).fontSize(14).fontWeight(FontWeight.Medium)
    }
    .height(36)
    .padding({ left: 14, right: 14 })
    .backgroundColor($r('app.color.primary_brand'))
    .fontColor(Color.White)
    .borderRadius(8)
    .onClick(action)
  }

  @Builder
  buildIconButton(icon: string, action: () => void): void {
    Button({ type: ButtonType.Circle, stateEffect: true }) {
      Text(icon).fontSize(18)
    }
        .width(36)
        .height(36)
    .backgroundColor(Color.Transparent)
    .fontColor($r('app.color.text_secondary'))
    .onClick(action)
    .margin({ left: 8 })
    .stateStyles({
      normal: {
        .backgroundColor(Color.Transparent)
      },
      pressed: {
        .backgroundColor($r('app.color.hover_bg'))
      }
    })
  }

  @Builder
  buildTabBar(): void {
    Scroll() {
      Row() {
        ForEach(this.tabs, (tab: EditorTab) => {
          this.buildTab(tab)
        })
      }
      .padding({ left: 12, right: 12, top: 8, bottom: 0 })
    }
    .scrollable(ScrollDirection.Horizontal)
    .scrollBar(BarState.Off)
    .height(44)
    .backgroundColor($r('app.color.background_secondary'))
  }

  @Builder
  buildTab(tab: EditorTab): void {
    Row() {
      Text(this.getFileIcon(tab.fileName))
        .fontSize(14)
        .margin({ right: 8 })

      Text(tab.fileName)
        .fontSize(13)
        .fontColor(tab.isActive ? $r('app.color.primary_brand') : $r('app.color.text_primary'))
        .fontWeight(tab.isActive ? FontWeight.Medium : FontWeight.Normal)
        .maxLines(1)
        .layoutWeight(1)

      if (tab.isModified) {
        Circle()
          .width(6)
          .height(6)
          .fill($r('app.color.warning_color'))
          .margin({ left: 6, right: 6 })
      }

      Button({ type: ButtonType.Circle }) {
        Text('√ó').fontSize(16).fontColor($r('app.color.text_tertiary'))
      }
      .width(18)
      .height(18)
      .backgroundColor(Color.Transparent)
      .onClick((): void => { this.closeTab(tab.id); })
    }
    .height(36)
    .padding({ left: 12, right: 8 })
    .backgroundColor(tab.isActive ? $r('app.color.background_primary') : Color.Transparent)
    .borderRadius({ topLeft: 8, topRight: 8 })
          .margin({ right: 4 })
    .onClick((): void => { this.switchToTab(tab.id); })
  }

  @Builder
  buildSidebar(): void {
    Column() {
      // Êñá‰ª∂ÊµèËßàÂô®Â§¥ÈÉ®
      Row() {
        Text('Êñá‰ª∂ÊµèËßàÂô®')
          .fontSize(14)
          .fontWeight(FontWeight.Bold)
          .fontColor($r('app.color.text_primary'))
          .layoutWeight(1)

        Button({ type: ButtonType.Circle }) {
          Text('‚ü≥').fontSize(16)
        }
        .width(28)
        .height(28)
        .backgroundColor(Color.Transparent)
          .fontColor($r('app.color.text_secondary'))
        .onClick((): void => { this.refreshFileTree(); })
      }
      .width('100%')
      .padding(16)
      .backgroundColor($r('app.color.surface_elevated'))

      Divider().color($r('app.color.border_light'))

      // Êñá‰ª∂Ê†ë
      if (this.fileTree.length === 0) {
        this.buildEmptySidebar()
      } else {
        Scroll() {
          Column() {
                ForEach(this.fileTree, (item: FileItem) => {
                  FileTreeItem({
                    fileItem: item,
                    level: 0,
                    isExpanded: this.expandedFolders.has(item.path),
                    isSelected: this.activeTab?.filePath === item.path,
                onFileClick: (file: FileItem): void => { this.onFileClick(file); },
                onFolderToggle: (file: FileItem): void => { this.toggleFolder(file); }
                  })
                }, (item: FileItem) => item.path)
              }
          .padding(8)
        }
        .layoutWeight(1)
      }
    }
    .width(280)
    .height('100%')
    .backgroundColor($r('app.color.surface_elevated'))
    .border({ width: { right: 1 }, color: $r('app.color.border_light') })
  }

  @Builder
  buildEmptySidebar(): void {
    Column() {
      Text('üìÇ').fontSize(48).margin({ bottom: 16 })
      Text('Êú™ÊâìÂºÄÊñá‰ª∂Â§π').fontSize(16).fontColor($r('app.color.text_secondary')).margin({ bottom: 8 })
      Text('ÁÇπÂáª‰∏äÊñπÊåâÈíÆÊâìÂºÄ').fontSize(13).fontColor($r('app.color.text_tertiary'))
    }
    .justifyContent(FlexAlign.Center)
    .layoutWeight(1)
  }

  @Builder
  buildEditor(): void {
      Column() {
      if (!this.activeTab) {
        this.buildWelcome()
      } else if (this.isMarkdownFile && this.isPreviewMode) {
        this.buildMarkdownPreview()
      } else {
        this.buildTextEditor()
      }
    }
      .layoutWeight(1)
    .width('100%')
    .height('100%')
    .backgroundColor($r('app.color.editor_background'))
  }

  @Builder
  buildWelcome(): void {
    Column() {
      Text('</>').fontSize(56).fontColor($r('app.color.primary_brand')).margin({ bottom: 24 })
      Text('ÈÄâÊã©‰∏Ä‰∏™Êñá‰ª∂ÂºÄÂßãÁºñËæë').fontSize(18).fontColor($r('app.color.text_secondary')).margin({ bottom: 32 })
      
      Button('ÊâìÂºÄÊñá‰ª∂')
            .fontSize(16)
        .backgroundColor($r('app.color.primary_brand'))
        .fontColor(Color.White)
          .borderRadius(8)
        .padding({ left: 24, right: 24, top: 12, bottom: 12 })
        .onClick((): void => { this.openFileDialog(); })
        }
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
    .width('100%')
    .height('100%')
  }

  @Builder
  buildTextEditor(): void {
      Column() {
      HighlightedText({
        code: this.editorContent,
        language: this.activeTab?.language || 'javascript',
        fontSize: 15,
        editable: true,
        onChange: (value: string): void => {
          this.editorContent = value;
          if (this.activeTab) {
            this.activeTab.content = value;
            this.activeTab.isModified = true;
          }
        }
      })
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  buildMarkdownPreview(): void {
    Scroll() {
      MarkdownPreview({
        markdown: this.editorContent,
        fontSize: 15
      })
      .width('100%')
      .padding(24)
    }
      .width('100%')
    .height('100%')
  }

  // === Êñá‰ª∂Êìç‰ΩúÊñπÊ≥ï ===
  async openFolderDialog(): Promise<void> {
    try {
      this.isLoading = true;
      console.log('ÂºÄÂßãÊâìÂºÄÊñá‰ª∂Â§πÈÄâÊã©Âô®...');
      const folderPath = await this.fileService.openFolderPicker();
      console.log('ÈÄâÊã©ÁöÑÊñá‰ª∂Â§π:', folderPath);
      
      if (folderPath) {
        this.currentFolder = folderPath;
        await this.loadFileTree();
      }
    } catch (error) {
      console.error('ÊâìÂºÄÊñá‰ª∂Â§πÂ§±Ë¥•:', error);
      console.error('ÈîôËØØËØ¶ÊÉÖ:', JSON.stringify(error));
    } finally {
      this.isLoading = false;
    }
  }

  async loadFileTree() {
    try {
      if (!this.currentFolder) return;
      this.isLoading = true;
      this.fileTree = await this.fileService.readDirectoryTree(this.currentFolder, 5);
    } catch (error) {
      console.error('Âä†ËΩΩÊñá‰ª∂Ê†ëÂ§±Ë¥•:', error);
    } finally {
      this.isLoading = false;
    }
  }

  async refreshFileTree() {
    await this.loadFileTree();
  }

  async openFileDialog(): Promise<void> {
    console.log('=== ÂºÄÂßãÊâìÂºÄÊñá‰ª∂ÂØπËØùÊ°Ü ===');
    try {
      console.log('[CodeEditor] 1. Ë∞ÉÁî® fileService.openFilePicker()');
      const filePaths = await this.fileService.openFilePicker();
      
      console.log('[CodeEditor] 2. ËøîÂõûÁªìÊûúÁ±ªÂûã:', typeof filePaths);
      console.log('[CodeEditor] 3. ËøîÂõûÁªìÊûú:', JSON.stringify(filePaths));
      console.log('[CodeEditor] 4. ÊòØÂê¶‰∏∫Êï∞ÁªÑ:', Array.isArray(filePaths));
      console.log('[CodeEditor] 5. Êï∞ÁªÑÈïøÂ∫¶:', filePaths?.length);
      
      if (filePaths && filePaths.length > 0) {
        console.log('[CodeEditor] 6. ÂºÄÂßãÊâìÂºÄÊñá‰ª∂ÔºåÊï∞Èáè:', filePaths.length);
        for (let i = 0; i < filePaths.length; i++) {
          const filePath = filePaths[i];
          console.log(`[CodeEditor] 7.${i} ÊâìÂºÄÊñá‰ª∂:`, filePath);
          await this.openFile(filePath);
        }
        console.log('[CodeEditor] 8. ÊâÄÊúâÊñá‰ª∂ÊâìÂºÄÂÆåÊàê');
          } else {
        console.log('[CodeEditor] ‚ö†Ô∏è Êú™ÈÄâÊã©‰ªª‰ΩïÊñá‰ª∂ÊàñËøîÂõû‰∏∫Á©∫');
      }
    } catch (error) {
      console.error('[CodeEditor] ‚ùå ÊâìÂºÄÊñá‰ª∂Â§±Ë¥•:', error);
      console.error('[CodeEditor] ÈîôËØØÁ±ªÂûã:', error?.constructor?.name);
      console.error('[CodeEditor] ÈîôËØØÊ∂àÊÅØ:', error?.message);
      console.error('[CodeEditor] ÈîôËØØËØ¶ÊÉÖ:', JSON.stringify(error));
    }
    console.log('=== Êñá‰ª∂ÂØπËØùÊ°ÜÂ§ÑÁêÜÁªìÊùü ===');
  }

  async openFile(filePath: string): Promise<void> {
    try {
      console.log('Ê≠£Âú®ÊâìÂºÄÊñá‰ª∂:', filePath);
      
      const tab = this.fileService.openFileInTab(filePath);
      console.log('ÂàõÂª∫Ê†áÁ≠æÈ°µ:', tab.fileName);
      
      const content = await this.fileService.readFileContent(filePath);
      console.log('ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπÔºåÈïøÂ∫¶:', content.length);
      
      tab.content = content;
      this.fileService.updateTabContent(tab.id, content);
      
      // Êõ¥Êñ∞Áä∂ÊÄÅ
      this.tabs = this.fileService.getTabs();
      this.activeTab = this.fileService.getActiveTab();
      this.editorContent = content;
      this.isMarkdownFile = this.markdownService.isMarkdownFile(tab.fileName);
      this.isPreviewMode = this.isMarkdownFile;
      
      console.log('Êñá‰ª∂ÊâìÂºÄÊàêÂäü:', {
        tabsCount: this.tabs.length,
        activeTab: this.activeTab?.fileName,
        contentLength: this.editorContent.length,
        isMarkdown: this.isMarkdownFile
      });
      
      // Âº∫Âà∂Âà∑Êñ∞Áä∂ÊÄÅ
      this.tabs = [...this.tabs];
    } catch (error) {
      console.error('ÊâìÂºÄÊñá‰ª∂Â§±Ë¥•:', error);
      console.error('ÈîôËØØËØ¶ÊÉÖ:', JSON.stringify(error));
    }
  }

  async saveCurrentFile() {
    if (!this.activeTab) return;
    try {
      const success = await this.fileService.writeFileContent(
        this.activeTab.filePath,
        this.editorContent
      );
      if (success) {
        this.fileService.markTabSaved(this.activeTab.id);
        this.activeTab.isModified = false;
      }
    } catch (error) {
      console.error('‰øùÂ≠òÊñá‰ª∂Â§±Ë¥•:', error);
    }
  }

  switchToTab(tabId: string) {
    this.fileService.setActiveTab(tabId);
    this.tabs = this.fileService.getTabs();
    this.activeTab = this.fileService.getActiveTab();
    if (this.activeTab) {
      this.loadTabContent(this.activeTab);
      this.isMarkdownFile = this.markdownService.isMarkdownFile(this.activeTab.fileName);
      if (!this.isMarkdownFile) {
        this.isPreviewMode = false;
      }
    }
  }

  async loadTabContent(tab: EditorTab) {
    try {
      this.editorContent = await this.fileService.readFileContent(tab.filePath);
    } catch (error) {
      console.error('Âä†ËΩΩÊ†áÁ≠æÈ°µÂÜÖÂÆπÂ§±Ë¥•:', error);
    }
  }

  closeTab(tabId: string) {
    this.fileService.closeTab(tabId);
    this.tabs = this.fileService.getTabs();
    this.activeTab = this.fileService.getActiveTab();
    if (this.activeTab) {
      this.loadTabContent(this.activeTab);
    } else {
      this.editorContent = '';
      this.isMarkdownFile = false;
      this.isPreviewMode = false;
    }
  }

  togglePreviewMode() {
    if (!this.isMarkdownFile) return;
    this.isPreviewMode = !this.isPreviewMode;
  }

  onFileClick(file: FileItem) {
    if (!file.isDirectory) {
      this.openFile(file.path);
    }
  }

  toggleFolder(folder: FileItem) {
    if (this.expandedFolders.has(folder.path)) {
      this.expandedFolders.delete(folder.path);
    } else {
      this.expandedFolders.add(folder.path);
    }
    this.expandedFolders = new Set(this.expandedFolders);
  }

  private cycleTheme() {
    const themes = this.themeService.getAvailableThemes();
    const currentIndex = themes.findIndex(t => t.id === this.currentTheme.id);
    const nextIndex = (currentIndex + 1) % themes.length;
    const nextTheme = themes[nextIndex];
    if (this.themeService.switchTheme(nextTheme.id)) {
      this.themeService.saveThemePreference(nextTheme.id);
    }
  }

  private handleSearchResult(result: SearchResult) {
    this.openFile(result.filePath);
  }

  private getFileIcon(fileName: string): string {
    const ext = fileName.split('.').pop()?.toLowerCase() || '';
    const icons: Record<string, string> = {
      'js': 'üü®', 'ts': 'üî∑', 'ets': 'üî∑', 'py': 'üêç',
      'java': '‚òï', 'html': 'üåê', 'css': 'üé®', 'json': 'üìã',
      'md': 'üìù', 'txt': 'üìÑ'
    };
    return icons[ext] || 'üìÑ';
  }

  private setupAutoSave() {
    this.autoSaveInterval = setInterval(() => {
      this.tabs.forEach(tab => {
        if (tab.isModified) {
          this.fileService.writeFileContent(tab.filePath, tab.content);
          this.fileService.markTabSaved(tab.id);
        }
      });
    }, 5 * 60 * 1000);
  }

  private cleanupAutoSave() {
    if (this.autoSaveInterval) {
      clearInterval(this.autoSaveInterval);
    }
  }
}