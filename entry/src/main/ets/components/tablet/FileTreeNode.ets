/**
 * æ–‡ä»¶æ ‘èŠ‚ç‚¹ç»„ä»¶
 * ç²¾ç¾çš„æ–‡ä»¶/æ–‡ä»¶å¤¹å±•ç¤ºï¼Œå¸¦åŠ¨ç”»æ•ˆæœ
 */
import { FileNode, ThemeColors } from '../../models/EditorModels'
import { curves } from '@kit.ArkUI'

@Component
export struct FileTreeNode {
  @Prop node: FileNode
  @Prop level: number = 0
  @Prop isExpanded: boolean = false
  @Prop isSelected: boolean = false
  @Prop colors: ThemeColors

  onSelect: (node: FileNode) => void = () => {}
  onToggle: (node: FileNode) => void = () => {}

  // åŠ¨ç”»çŠ¶æ€
  @State hoverState: boolean = false
  @State pressState: boolean = false
  @State arrowRotation: number = 0
  @State itemScale: number = 1
  @State iconBounce: number = 0
  @State bgOpacity: number = 0

  aboutToAppear() {
    this.arrowRotation = this.isExpanded ? 90 : 0
  }

  build() {
    Row() {
      // ç¼©è¿›
      Blank().width(this.level * 16 + 8)

      // å±•å¼€ç®­å¤´ï¼ˆä»…æ–‡ä»¶å¤¹ï¼‰
      if (this.node.type === 'folder') {
        Text('â–¶')
          .fontSize(9)
          .fontColor(this.isSelected ? this.colors.primary : this.colors.textSecondary)
          .width(16)
          .textAlign(TextAlign.Center)
          .rotate({ angle: this.arrowRotation })
          .animation({
            duration: 250,
            curve: curves.springMotion(0.5, 0.85)
          })
      } else {
        Blank().width(16)
      }

      // æ–‡ä»¶å›¾æ ‡
      Text(this.getFileIcon())
        .fontSize(16)
        .margin({ left: 4, right: 10 })
        .translate({ y: this.iconBounce })
        .animation({
          duration: 300,
          curve: curves.springMotion(0.35, 0.7)
        })

      // æ–‡ä»¶å
      Text(this.node.name)
        .fontSize(13)
        .fontColor(this.isSelected ? this.colors.primary : this.colors.textPrimary)
        .fontWeight(this.isSelected ? FontWeight.Medium : FontWeight.Normal)
        .maxLines(1)
        .textOverflow({ overflow: TextOverflow.Ellipsis })
        .layoutWeight(1)

      // æ–‡ä»¶å¤§å°ï¼ˆä»…æ–‡ä»¶ï¼‰
      if (this.node.type === 'file' && this.node.size) {
        Text(this.formatSize(this.node.size))
          .fontSize(11)
          .fontColor(this.colors.textDisabled)
          .margin({ right: 8 })
          .opacity(this.hoverState ? 1 : 0)
          .animation({
            duration: 150,
            curve: Curve.EaseOut
          })
      }
    }
    .width('100%')
    .height(34)
    .padding({ right: 8 })
    .scale({ x: this.itemScale, y: this.itemScale })
    .backgroundColor(this.getBackgroundColor())
    .borderRadius(8)
    .margin({ left: 4, right: 4, top: 1, bottom: 1 })
    .animation({
      duration: 180,
      curve: curves.springMotion(0.6, 0.95)
    })
    // æ‚¬åœæ•ˆæœ
    .onHover((isHover: boolean) => {
      this.hoverState = isHover
      if (isHover) {
        // å›¾æ ‡å¼¹è·³
        this.iconBounce = -2
        setTimeout(() => {
          this.iconBounce = 0
        }, 100)
      }
    })
    // ç‚¹å‡»æ•ˆæœ
    .onTouch((event: TouchEvent) => {
      if (event.type === TouchType.Down) {
        this.pressState = true
        this.itemScale = 0.98
      } else if (event.type === TouchType.Up || event.type === TouchType.Cancel) {
        this.pressState = false
        this.itemScale = 1
      }
    })
    .onClick(() => {
      if (this.node.type === 'folder') {
        // å±•å¼€/æŠ˜å åŠ¨ç”»
        this.arrowRotation = this.isExpanded ? 0 : 90
        this.onToggle(this.node)
      } else {
        this.onSelect(this.node)
      }
    })
  }

  getBackgroundColor(): ResourceColor {
    if (this.isSelected) {
      return this.colors.active
    } else if (this.pressState) {
      return this.colors.pressed
    } else if (this.hoverState) {
      return this.colors.hover
    }
    return Color.Transparent
  }

  getFileIcon(): string {
    if (this.node.type === 'folder') {
      return this.isExpanded ? 'ğŸ“‚' : 'ğŸ“'
    }

    // æ ¹æ®æ‰©å±•åè¿”å›å›¾æ ‡
    const ext = this.node.extension?.toLowerCase() || ''
    const iconMap: Record<string, string> = {
      'ets': 'ğŸ”¶',
      'ts': 'ğŸ”·',
      'js': 'ğŸŸ¨',
      'json': 'ğŸ“‹',
      'json5': 'ğŸ“‹',
      'md': 'ğŸ“',
      'html': 'ğŸŒ',
      'css': 'ğŸ¨',
      'py': 'ğŸ',
      'java': 'â˜•',
      'c': 'ğŸ“˜',
      'cpp': 'ğŸ“˜',
      'h': 'ğŸ“‘',
      'txt': 'ğŸ“„',
      'xml': 'ğŸ“°',
      'yaml': 'âš™ï¸',
      'yml': 'âš™ï¸',
      'sh': 'ğŸ–¥ï¸',
      'bat': 'ğŸ–¥ï¸'
    }
    return iconMap[ext] || 'ğŸ“„'
  }

  formatSize(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
  }
}
