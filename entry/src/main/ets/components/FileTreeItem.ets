/**
 * æ–‡ä»¶æ ‘é¡¹ç»„ä»¶
 * ç”¨äºæ˜¾ç¤ºæ–‡ä»¶å’Œæ–‡ä»¶å¤¹çš„æ ‘å½¢ç»“æ„
 */
import { FileItem } from '../models/FileModel';
import { ThemeService, Theme } from '../services/ThemeService';

@Component
export struct FileTreeItem {
  @Prop fileItem: FileItem = {
    name: '',
    path: '',
    type: '',
    size: 0,
    lastModified: 0,
    isDirectory: false
  };
  @Prop level: number = 0;
  @Prop isExpanded: boolean = false;
  @Prop isSelected: boolean = false;
  
  @State private currentTheme: Theme = ThemeService.getInstance().getCurrentTheme();
  
  onFileClick: (file: FileItem) => void = () => {};
  onFolderToggle: (folder: FileItem) => void = () => {};
  
  private themeService: ThemeService = ThemeService.getInstance();

  aboutToAppear() {
    this.themeService.onThemeChange((theme: Theme) => {
      this.currentTheme = theme;
    });
  }

  build() {
    Column() {
      // å½“å‰é¡¹
      Row() {
        // ç¼©è¿›
        Blank()
          .width(this.level * 16)

        // å±•å¼€/æŠ˜å å›¾æ ‡ï¼ˆä»…æ–‡ä»¶å¤¹ï¼‰
        if (this.fileItem.isDirectory) {
          Text('â–¶')
            .fontSize(10)
            .fontColor(this.currentTheme.colors.textSecondary)
            .width(16)
            .textAlign(TextAlign.Center)
            .margin({ right: 6 })
            .rotate({ angle: this.isExpanded ? 90 : 0 })
            .animation({
              duration: 200,
              curve: Curve.EaseInOut
            })
        } else {
          Blank().width(22)
        }

        // æ–‡ä»¶/æ–‡ä»¶å¤¹å›¾æ ‡
        Text(this.getFileIcon())
          .fontSize(16)
          .margin({ right: 8 })

        // æ–‡ä»¶å
        Text(this.fileItem.name)
          .fontSize(14)
          .fontColor(this.isSelected ? this.currentTheme.colors.primary : this.currentTheme.colors.text)
          .fontWeight(this.isSelected ? FontWeight.Medium : FontWeight.Normal)
          .layoutWeight(1)
          .maxLines(1)
          .textOverflow({ overflow: TextOverflow.Ellipsis })

        // æ–‡ä»¶å¤§å°ï¼ˆä»…æ–‡ä»¶ï¼‰
        if (!this.fileItem.isDirectory && this.fileItem.size > 0) {
          Text(this.formatFileSize(this.fileItem.size))
            .fontSize(11)
            .fontColor(this.currentTheme.colors.textSecondary)
            .margin({ left: 8 })
        }
      }
      .width('100%')
      .height(36)
      .padding({ left: 8, right: 12 })
      .backgroundColor(this.isSelected ? this.currentTheme.colors.surface : Color.Transparent)
      .borderRadius(6)
      .onClick(() => {
        if (this.fileItem.isDirectory) {
          this.onFolderToggle(this.fileItem);
        } else {
          this.onFileClick(this.fileItem);
        }
      })
      .stateStyles({
        normal: {
          .opacity(1)
        },
        pressed: {
          .opacity(0.7)
        }
      })

      // å­é¡¹ï¼ˆä»…å½“æ˜¯æ–‡ä»¶å¤¹ä¸”å±•å¼€æ—¶ï¼‰
      if (this.fileItem.isDirectory && this.isExpanded && this.fileItem.children && this.fileItem.children.length > 0) {
        Column() {
          ForEach(this.fileItem.children, (child: FileItem) => {
            FileTreeItem({
              fileItem: child,
              level: this.level + 1,
              isExpanded: false,
              isSelected: false,
              onFileClick: this.onFileClick,
              onFolderToggle: this.onFolderToggle
            })
          }, (child: FileItem) => child.path)
        }
        .width('100%')
        .transition({
          type: TransitionType.Insert,
          opacity: 0,
          translate: { x: -10, y: -10 },
          scale: { x: 0.95, y: 0.95 }
        })
        .transition({
          type: TransitionType.Delete,
          opacity: 0,
          translate: { x: -10, y: 0 }
        })
      }
    }
    .width('100%')
  }

  /**
   * è·å–æ–‡ä»¶å›¾æ ‡
   */
  private getFileIcon(): string {
    if (this.fileItem.isDirectory) {
      return this.isExpanded ? 'ğŸ“‚' : 'ğŸ“';
    }

    const ext = this.fileItem.type.toLowerCase();
    const iconMap: Record<string, string> = {
      'js': 'ğŸ“œ',
      'ts': 'ğŸ“˜',
      'ets': 'ğŸ“˜',
      'json': 'ğŸ“‹',
      'md': 'ğŸ“',
      'html': 'ğŸŒ',
      'css': 'ğŸ¨',
      'py': 'ğŸ',
      'java': 'â˜•',
      'cpp': 'âš™ï¸',
      'c': 'âš™ï¸',
      'txt': 'ğŸ“„',
      'xml': 'ğŸ“°',
      'yaml': 'âš™ï¸',
      'yml': 'âš™ï¸'
    };

    return iconMap[ext] || 'ğŸ“„';
  }

  /**
   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
   */
  private formatFileSize(bytes: number): string {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(1)} KB`;
    } else {
      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    }
  }
}

